<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>物理撞车模拟器</title>
<style>
body { margin: 0; overflow: hidden; }
canvas { display: block; }
#controls {
  position: absolute;
  left: 20px;
  bottom: 20px;
  background: rgba(0,0,0,0.5);
  padding: 15px;
  border-radius: 10px;
  color: #fff;
  font-family: sans-serif;
}
#controls label { display:block; margin:5px 0; }
</style>
</head>
<body>

<div id="controls">
  <label>方向盘：A / D</label>
  <label>加速 / 后退：W / S</label>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>

<script>
// =================== 基础场景 ===================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb); // 天空蓝
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 10, 20);
camera.lookAt(0,0,0);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 光源
const ambient = new THREE.AmbientLight(0xffffff,0.6);
scene.add(ambient);
const dirLight = new THREE.DirectionalLight(0xffffff,0.8);
dirLight.position.set(10,20,10);
scene.add(dirLight);

// =================== 地面 ===================
const groundGeo = new THREE.BoxGeometry(100,1,100);
const groundMat = new THREE.MeshStandardMaterial({color:0x555555});
const groundMesh = new THREE.Mesh(groundGeo, groundMat);
groundMesh.position.y = -0.5;
scene.add(groundMesh);

// =================== 物理世界 ===================
const world = new CANNON.World({gravity: new CANNON.Vec3(0,-9.82,0)});
const groundBody = new CANNON.Body({
  mass:0,
  shape: new CANNON.Box(new CANNON.Vec3(50,0.5,50))
});
groundBody.position.set(0,-0.5,0);
world.addBody(groundBody);

// =================== 玩家车 ===================
const carGeo = new THREE.BoxGeometry(2,1,4);
const carMat = new THREE.MeshStandardMaterial({color:0xff0000});
const carMesh = new THREE.Mesh(carGeo, carMat);
scene.add(carMesh);

const carShape = new CANNON.Box(new CANNON.Vec3(1,0.5,2));
const carBody = new CANNON.Body({ mass: 150 });
carBody.addShape(carShape);
carBody.position.set(0,1,0);
carBody.angularDamping = 0.5; // 阻尼
world.addBody(carBody);

// =================== 障碍物 ===================
function addObstacle(x,z){
    const boxGeo = new THREE.BoxGeometry(2,2,2);
    const boxMat = new THREE.MeshStandardMaterial({color:0x00ff00});
    const boxMesh = new THREE.Mesh(boxGeo, boxMat);
    boxMesh.position.set(x,1,z);
    scene.add(boxMesh);

    const boxShape = new CANNON.Box(new CANNON.Vec3(1,1,1));
    const boxBody = new CANNON.Body({mass:50});
    boxBody.addShape(boxShape);
    boxBody.position.set(x,1,z);
    world.addBody(boxBody);
}
addObstacle(5,0);
addObstacle(-5,-10);
addObstacle(10,10);

// =================== 控制 ===================
let forward = false;
let backward = false;
let left = false;
let right = false;

document.addEventListener('keydown', (e)=>{
    if(e.code === 'KeyW') forward = true;
    if(e.code === 'KeyS') backward = true;
    if(e.code === 'KeyA') left = true;
    if(e.code === 'KeyD') right = true;
});
document.addEventListener('keyup', (e)=>{
    if(e.code === 'KeyW') forward = false;
    if(e.code === 'KeyS') backward = false;
    if(e.code === 'KeyA') left = false;
    if(e.code === 'KeyD') right = false;
});

// =================== 动画循环 ===================
const clock = new THREE.Clock();
function animate(){
    requestAnimationFrame(animate);
    const dt = clock.getDelta();

    // 车子控制
    const force = 500;
    if(forward) carBody.applyLocalForce(new CANNON.Vec3(0,0,-force), new CANNON.Vec3(0,0,0));
    if(backward) carBody.applyLocalForce(new CANNON.Vec3(0,0,force), new CANNON.Vec3(0,0,0));
    if(left) carBody.angularVelocity.y += 1*dt*5;
    if(right) carBody.angularVelocity.y -= 1*dt*5;

    world.step(1/60, dt, 3);

    // 更新车子位置
    carMesh.position.copy(carBody.position);
    carMesh.quaternion.copy(carBody.quaternion);

    renderer.render(scene, camera);
}
animate();

// =================== 调整窗口 ===================
window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
