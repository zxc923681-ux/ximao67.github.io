<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>移动端真实物理撞车模拟器 - XM HUB</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
body { margin:0; overflow:hidden; background:#87ceeb; touch-action:none; }
canvas { display:block; }
#instructions{
  position:absolute; left:10px; top:10px; background:rgba(0,0,0,0.5); color:#fff; padding:10px; border-radius:8px; font-family:sans-serif; width:220px;
}
#footer{
  position:absolute; bottom:0; width:100%; text-align:center; background:rgba(0,0,0,0.5); color:#fff; padding:10px; font-family:sans-serif;
}
#joystickContainer{
  position:absolute; bottom:80px; left:20px; width:120px; height:120px; touch-action:none;
}
#throttle{
  position:absolute; bottom:80px; right:20px; width:80px; height:80px; background:rgba(0,0,0,0.3); border-radius:50%; touch-action:none; display:flex; align-items:center; justify-content:center; font-size:20px; color:white; font-weight:bold;
}
</style>
</head>
<body>

<div id="instructions">
  <h3>物理车辆模拟器</h3>
  <p>触屏控制：</p>
  <ul>
    <li>左下方向盘：控制转向</li>
    <li>右下按钮：油门/刹车</li>
  </ul>
  <p>作者 QQ: <a href="tencent://message/?Menu=yes&Uin=366118610" style="color:#0ff;">366118610</a></p>
  <p>作者微信: George0131122</p>
</div>

<div id="footer">XM HUB - Roblox脚本物理学习模拟器</div>
<div id="joystickContainer"></div>
<div id="throttle">油门</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>
<script src="https://cdn.jsdelivr.net/npm/nipplejs@0.10.3/dist/nipplejs.min.js"></script>

<script>
// =================== Three.js 场景 ===================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

// 摄像机
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,10,20);
camera.lookAt(0,0,0);

// 渲染器
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 光源
scene.add(new THREE.AmbientLight(0xffffff,0.6));
const dirLight = new THREE.DirectionalLight(0xffffff,0.8);
dirLight.position.set(10,20,10);
scene.add(dirLight);

// =================== Cannon.js 物理 ===================
const world = new CANNON.World({gravity:new CANNON.Vec3(0,-9.82,0)});
world.broadphase = new CANNON.NaiveBroadphase();
world.solver.iterations = 10;

// =================== 地面 ===================
const groundGeo = new THREE.BoxGeometry(200,1,200);
const groundMat = new THREE.MeshStandardMaterial({color:0x555555});
const groundMesh = new THREE.Mesh(groundGeo, groundMat);
groundMesh.position.y=-0.5;
scene.add(groundMesh);

const groundBody = new CANNON.Body({mass:0});
groundBody.addShape(new CANNON.Box(new CANNON.Vec3(100,0.5,100)));
groundBody.position.set(0,-0.5,0);
world.addBody(groundBody);

// =================== 建筑物 ===================
function addBuilding(x,z,w,h,d){
  const geo = new THREE.BoxGeometry(w,h,d);
  const mat = new THREE.MeshStandardMaterial({color:0x888888});
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x,h/2,z);
  scene.add(mesh);

  const shape = new CANNON.Box(new CANNON.Vec3(w/2,h/2,d/2));
  const body = new CANNON.Body({mass:0});
  body.addShape(shape);
  body.position.set(x,h/2,z);
  world.addBody(body);
}
addBuilding(15,0,4,10,4);
addBuilding(-15,-10,6,15,6);
addBuilding(0,20,10,20,10);
addBuilding(25,15,8,12,8);
addBuilding(-25,20,5,10,5);

// =================== 障碍物 ===================
function addObstacle(x,z){
  const geo = new THREE.BoxGeometry(2,2,2);
  const mat = new THREE.MeshStandardMaterial({color:0x00ff00});
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x,1,z);
  scene.add(mesh);

  const shape = new CANNON.Box(new CANNON.Vec3(1,1,1));
  const body = new CANNON.Body({mass:50});
  body.addShape(shape);
  body.position.set(x,1,z);
  world.addBody(body);
}
[5,0,-5,-10,10,10,20,-5,-15,15].forEach((v,i)=>addObstacle(i%2? v : v,v));

// =================== 车辆 ===================
const carBodyShape = new CANNON.Box(new CANNON.Vec3(1,0.5,2));
const carBody = new CANNON.Body({mass:150});
carBody.addShape(carBodyShape);
carBody.position.set(0,1,0);
carBody.angularDamping=0.5;
world.addBody(carBody);

const carMesh = new THREE.Mesh(new THREE.BoxGeometry(2,1,4), new THREE.MeshStandardMaterial({color:0xff0000}));
scene.add(carMesh);

// 真实轮子模拟
const wheelMeshes=[],wheelBodies=[],wheelPositions=[
  new CANNON.Vec3(-0.9,-0.5,1.5),
  new CANNON.Vec3(0.9,-0.5,1.5),
  new CANNON.Vec3(-0.9,-0.5,-1.5),
  new CANNON.Vec3(0.9,-0.5,-1.5)
];

for(let i=0;i<4;i++){
  const wMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,0.3,16), new THREE.MeshStandardMaterial({color:0x111111}));
  wMesh.rotation.z=Math.PI/2;
  scene.add(wMesh);
  wheelMeshes.push(wMesh);

  const wShape = new CANNON.Cylinder(0.5,0.5,0.3,16);
  const wBody = new CANNON.Body({mass:20});
  wBody.addShape(wShape,new CANNON.Vec3(0,0,0));
  wBody.position.copy(carBody.position.vadd(wheelPositions[i]));
  world.addBody(wBody);
  wheelBodies.push(wBody);
}

// =================== 触屏控制 ===================
let steer=0, throttle=0;
const joystick = nipplejs.create({
  zone: document.getElementById('joystickContainer'),
  mode: 'static', position: {left:'60px', top:'60px'},
  color: 'white', size:100
});
joystick.on('move',(evt,data)=>{ if(data&&data.vector) steer=data.vector.x; });
joystick.on('end',()=>{steer=0;});

const throttleBtn = document.getElementById('throttle');
throttleBtn.addEventListener('touchstart', ()=>throttle=1);
throttleBtn.addEventListener('touchend', ()=>throttle=0);

// =================== 动画循环 ===================
const clock=new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const dt=clock.getDelta();

  // 控制车辆
  const force=600;
  if(throttle) carBody.applyLocalForce(new CANNON.Vec3(0,0,-force), new CANNON.Vec3(0,0,0));
  carBody.angularVelocity.y += steer*dt*5;

  world.step(1/60, dt, 3);

  // 更新车身
  carMesh.position.copy(carBody.position);
  carMesh.quaternion.copy(carBody.quaternion);

  // 更新轮子位置
  for(let i=0;i<4;i++){
    wheelMeshes[i].position.copy(carBody.position.vadd(wheelPositions[i]));
    wheelMeshes[i].quaternion.copy(carBody.quaternion);
  }

  // 摄像机跟随
  camera.position.lerp(new THREE.Vector3(carMesh.position.x, carMesh.position.y+10, carMesh.position.z+20),0.1);
  camera.lookAt(carMesh.position);

  renderer.render(scene,camera);
}
animate();

window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
